<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java面向对象（上）</title>
    <link href="/2020/09/17/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <url>/2020/09/17/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Java面向对象（上）"><a href="#Java面向对象（上）" class="headerlink" title="Java面向对象（上）"></a>Java面向对象（上）</h1><p>​        在开始学习Java之前就知道Java是一种面向对象的编程语言，但是对于什么是面向对象却没有明确的了解，在学习了本章之后，对于面向对象有了初步的了解，本篇文章梳理了该章节的重点知识。</p><p>​        如果感兴趣的话就继续看下去吧！</p><a id="more"></a><h3 id="面向对象的概念"><a href="#面向对象的概念" class="headerlink" title="面向对象的概念"></a>面向对象的概念</h3><p>​        <strong>面向对象程序设计</strong>（英语：Object-oriented programming，<a href="https://zh.wikipedia.org/wiki/缩写" target="_blank" rel="noopener">缩写</a>：OOP）是种具有<a href="https://zh.wikipedia.org/wiki/对象_(计算机科学" target="_blank" rel="noopener">对象</a>)概念的<a href="https://zh.wikipedia.org/wiki/编程范型" target="_blank" rel="noopener">程序编程典范</a>，同时也是一种程序开发的抽象方针。</p><p>​        简单概括，面向对象开发是相对于结构化开发而言的，这种思想的产生来源于自然界，对于存在于自然界中的所有物质我们都能够将他归类，例如人类、动物类、食物类等等，而对于这些类我们都能够概括定义出他的属性和功能。针对程序设计，我们可以把程序看作是各种对象的集合。</p><blockquote><p>程序    =    自然界</p><p>对象    =    人类、动物类……    </p></blockquote><h3 id="面向对象的特点"><a href="#面向对象的特点" class="headerlink" title="面向对象的特点"></a>面向对象的特点</h3><ul><li>封装性：核心，将对象的属性和行为封装成类，实现对用户隐藏细节</li><li>继承性：不同类之间关系的一种，目前还不太明确:(</li><li>多态性：以统一的风格编写程序</li></ul><h2 id="1-类与对象"><a href="#1-类与对象" class="headerlink" title="1. 类与对象"></a>1. 类与对象</h2><h3 id="1-1-类与对象的关系"><a href="#1-1-类与对象的关系" class="headerlink" title="1.1 类与对象的关系"></a>1.1 类与对象的关系</h3><blockquote><p> 类是一种抽象的概念模板，对象是类在程序中的实例</p><p> 静态部分（属性）    =    成员变量</p><p> 动态部分（功能）    =    成员方法</p></blockquote><p>​        例如：男人、女人是<code>类（class）</code>，具体的某个人就是该类的<code>对象（object）</code>。</p><h3 id="1-2-Java中的类"><a href="#1-2-Java中的类" class="headerlink" title="1.2 Java中的类"></a>1.2 Java中的类</h3><p>​        类是对象的一个模板，描述的是一类对象的行为和状态。一个类中可以包含一下变量：</p><ul><li><p>局部变量</p></li><li><p>成员变量</p></li><li><p>类变量（静态变量）</p><h4 id="1-2-1-构造方法"><a href="#1-2-1-构造方法" class="headerlink" title="1.2.1 构造方法"></a>1.2.1 构造方法</h4></li></ul><p>​        每个类至少要有一个构造方法，构造方法的名称与类同名。如果没有显式的定义构造方法，那么系统就会提供默认构造方法。</p><blockquote><p>注意：</p><p>1.构造方法没有返回值类型，不能使用return返回一个值</p></blockquote><h5 id="构造方法中可能出现的错误"><a href="#构造方法中可能出现的错误" class="headerlink" title="构造方法中可能出现的错误"></a>构造方法中可能出现的错误</h5><p>​        当定义有参数的构造方法时，系统就不会再提供默认构造方法，可能会导致出错。</p><h5 id="构造方法的重载"><a href="#构造方法的重载" class="headerlink" title="构造方法的重载"></a>构造方法的重载</h5><p>​        定义参数列表不同的构造方法，在实例化对象时，系统会自动调用参数列表匹配的构造方法</p><h4 id="1-2-2-类的封装"><a href="#1-2-2-类的封装" class="headerlink" title="1.2.2 类的封装"></a>1.2.2 类的封装</h4><p>​        类的封装能够隐藏类的实现细节，主要方法</p><blockquote><p>通过private修饰私有属性，通过public公有化属性访问器（setXXX &amp;&amp; get XXX)</p></blockquote><h3 id="1-3-Java中的对象"><a href="#1-3-Java中的对象" class="headerlink" title="1.3 Java中的对象"></a>1.3 Java中的对象</h3><p>​        对象是根据类创建的，创建对象需要以下三步：</p><ul><li>声明对象：包括对象名（引用变量）和对象类型</li><li>实例化：使用new关键字创建对象，开辟独立的堆内存空间</li><li>初始化：使用new创建对象时，会调用构造方法初始化对象</li></ul><h2 id="2-this关键词"><a href="#2-this关键词" class="headerlink" title="2. this关键词"></a>2. this关键词</h2><p>​        为了避免冲突，this表示当前的对象，主要有以下三种用法：</p><h3 id="2-1-this调用类的属性"><a href="#2-1-this调用类的属性" class="headerlink" title="2.1 this调用类的属性"></a>2.1 this调用类的属性</h3><p>​        当成员变量与局部变量重名时，使用this明确调用类的成员变量</p><h3 id="2-2-this调用类的成员方法"><a href="#2-2-this调用类的成员方法" class="headerlink" title="2.2 this调用类的成员方法"></a>2.2 this调用类的成员方法</h3><p>​        用与访问成员变量相同的方式访问成员方法</p><h3 id="2-3-this调用类的构造方法"><a href="#2-3-this调用类的构造方法" class="headerlink" title="2.3 this调用类的构造方法"></a>2.3 this调用类的构造方法</h3><p>​        调用方法：使用this[实参列表]调通其他的构造方法</p><blockquote><p>注意:</p><p>1.在构造方法中调用构造方法（一层套娃）只能出现一次，并且this（）语句必须位于该构造方法的第一句。</p><p>2.需要留一个构造方法作为出口，至少存在一个构造方法不使用this调用其他构造方法（通常将无参数的构造方法作为出口）</p></blockquote><h2 id="3-Java中的垃圾回收机制"><a href="#3-Java中的垃圾回收机制" class="headerlink" title="3.  Java中的垃圾回收机制"></a>3.  Java中的垃圾回收机制</h2><p>​        Java会自动回收堆内存中的垃圾空间，除此之外，还可以人为调用System. gc()方法建议需虚拟机立即执行垃圾回收，但是否执行并不能确定。</p><p>​        Stop-the-World是由于要执行GC操作而停止整个程序的执行，任何一个GC操作都会发生，此时所有的线程都会处于等待状态，对GC的优化就是减少Stop-the-World的发生次数，使系统具有<strong>高吞吐、低停顿</strong>的特点。</p><blockquote><p><a href="https://blog.csdn.net/justloveyou_/article/details/71216049" target="_blank" rel="noopener">Java中的自动回收机制参考文章</a></p></blockquote><h2 id="4-static关键词"><a href="#4-static关键词" class="headerlink" title="4.  static关键词"></a>4.  static关键词</h2><h3 id="4-1-静态变量"><a href="#4-1-静态变量" class="headerlink" title="4.1 静态变量"></a>4.1 静态变量</h3><blockquote><p>静态变量：使用static修饰的关键词修饰的成员变量，能够被类的所有对象所共同访问，可以直接通过类名来访问</p><p>实例变量：未使用static修饰的成员变量，只能够通过引用变量访问</p></blockquote><ul><li>注意：static在修饰变量的时候只能够修饰成员变量，不能够修饰方法中的局部变量</li></ul><h3 id="4-2-静态方法"><a href="#4-2-静态方法" class="headerlink" title="4.2 静态方法"></a>4.2 静态方法</h3><p>​        静态方法的调用不需要创建类的实例，可以直接通过类名调用</p><ul><li>注意：静态方法只能够访问类的静态成员，不能够访问实例成员。<code>原因：static修饰的成员属于类，而未被static修饰的成员都是属于对象的</code></li></ul><h3 id="4-3-代码块"><a href="#4-3-代码块" class="headerlink" title="4.3 代码块"></a>4.3 代码块</h3><p>​        使用<code>{}</code>括起来的一段代码，可以分为普通代码块、构造代码块、静态代码块、同步代码块</p><h4 id="4-3-1-普通代码块"><a href="#4-3-1-普通代码块" class="headerlink" title="4.3.1 普通代码块"></a>4.3.1 普通代码块</h4><p>​        用在方法名后或方法体内，使用最多的、最普通的代码块</p><h4 id="4-3-2-构造代码块"><a href="#4-3-2-构造代码块" class="headerlink" title="4.3.2 构造代码块"></a>4.3.2 构造代码块</h4><p>​        直接定义在类中，只有一对花括号，构造代码块在构造方法之前执行，同样是在创建对象时被自动调用。</p><p>​        可用于初始化成员变量。</p><blockquote><p>多个构造代码都需要初始化成员变量，可将重复的部分提取，构成构造代码块</p></blockquote><h4 id="4-3-3-静态代码块"><a href="#4-3-3-静态代码块" class="headerlink" title="4.3.3 静态代码块"></a>4.3.3 静态代码块</h4><p>​        使用static修饰，最早执行的代码块，只会执行一次。</p><h4 id="4-3-4-单例模式"><a href="#4-3-4-单例模式" class="headerlink" title="4.3.4 单例模式"></a>4.3.4 单例模式</h4><p>​        单例模式是一种设计模式。单例类只创建自己唯一的实例，只给全局提供一个直接访问点。</p><blockquote><p><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。</p><p><strong>何时使用：</strong>当您想控制实例数目，节省系统资源的时候。</p></blockquote><h2 id="5-内部类"><a href="#5-内部类" class="headerlink" title="5. 内部类"></a>5. 内部类</h2><p>​        在类中定义的类，他所在的类称为外部类。</p><blockquote><p>1.内部类和外部类是两个独立的类。</p><p>2.内部类可以看成是外部类的一个成员，故内部类可以访问外部类的任何其他成员。</p><p>3.内部类可被static修饰为静态，外部类只能用public或默认的访问权限</p></blockquote><h3 id="5-1-成员内部类"><a href="#5-1-成员内部类" class="headerlink" title="5.1 成员内部类"></a>5.1 成员内部类</h3><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><blockquote><p>​    向外：能直接访问外部类的所有成员</p><p>​    向内：外部类只能通过创建内部类的对象来访问内部类的成员</p></blockquote><ul><li>注意：成员内部类不能定义静态变量、静态方法和静态内部量</li></ul><h3 id="5-2-静态内部类"><a href="#5-2-静态内部类" class="headerlink" title="5.2 静态内部类"></a>5.2 静态内部类</h3><p>​        可以有实例成员和静态成员。</p><blockquote><p> 向外：直接访问外部类的静态成员；</p><p> ​            必须通过外部类的对象访问外部类的实例成员</p><p> 向内：访问静态内部类成员，不用创建外部类对象，只需创建内部类对象</p></blockquote><h3 id="5-3-方法内部类"><a href="#5-3-方法内部类" class="headerlink" title="5.3 方法内部类"></a>5.3 方法内部类</h3><p>​        成员方法中定义的类，作用域为定义它的代码块，只能在该成员方法内实例化。</p><blockquote><p>向外：也能够访问外部类成员</p></blockquote><h3 id="5-4-匿名内部类"><a href="#5-4-匿名内部类" class="headerlink" title="5.4 匿名内部类"></a>5.4 匿名内部类</h3><p>​        暂时没理解…</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>在搭建和优化Hexo时遇到的问题</title>
    <link href="/2020/08/28/%E5%9C%A8%E6%90%AD%E5%BB%BA%E5%92%8C%E4%BC%98%E5%8C%96Hexo%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2020/08/28/%E5%9C%A8%E6%90%AD%E5%BB%BA%E5%92%8C%E4%BC%98%E5%8C%96Hexo%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>记录自己在搭建博客的过程中所遇到的问题以及最终的解决办法</p><a id="more"></a><h3 id="修改背景图的问题"><a href="#修改背景图的问题" class="headerlink" title="修改背景图的问题"></a>修改背景图的问题</h3><p>​        今天想要进一步的优化一下自己疫情期间搭建的博客，想要解决替换页面背景的问题。由于NexT版本的更新，在搜索引擎上得到的大部分指引都是针对在NexT 7.3.0以前的文件设置，而在NexT 7.3.0之后的版本无法找到<code>hexo/next/source/css/_custom/_custom.styl</code>文件，搜索到的解决办法也五花八门，尝试了很多方法都出现了不同的错误，比如今天所遇到的错误:</p><ul><li>初步尝试<ul><li>将原本放在<code>hexo/next/source/css/_custom/_custom.styl</code>中的自定义样式代码放在<code>hexo/source/_data/styles.styl</code>中</li><li>在NexT的基本配置文件中将<code>#style: source/_data/styles.styl</code>的注释符号删除</li></ul></li></ul><ul><li><p>出现错误</p><pre><code class="hljs subunit"><span class="hljs-keyword">ERROR </span>Asset render failed: css/main.css<span class="hljs-keyword">Error: </span>D:\blog\themes\next\source\css\main.styl:47:11   43|   44| // Custom Layer   45| // --------------------------------------------------   46| for $inject_style in hexo-config('injects.style')   47|   @import $inject_style;-----------------^   48|failed to locate @import file D:\blog\source\_data\styles.styl</code></pre><p>根据提示，我们推断是无法定位到指定文件，而该文件正是我们修改的<code>D:\blog\source\_data\styles.styl</code></p></li></ul><ul><li><p>解决办法</p><ul><li><p>参考作者：<a href="https://www.cnblogs.com/lyshark" target="_blank" rel="noopener">lyshark</a>（文章出处：<a href="https://www.cnblogs.com/lyshark）所给出的解决办法，在NexT" target="_blank" rel="noopener">https://www.cnblogs.com/lyshark）所给出的解决办法，在NexT</a> 7.3.0之后的版本，原本写在<code>hexo/next/source/css/_custom/_custom.styl</code>中的自定义样式代码，直接复制到错误提示的<code>D:\blog\themes\next\source\css\main.styl</code>中即可，最终修改成功的文件如下</p><pre><code class="hljs xl"><span class="hljs-comment">// CSS Style Guide: http://codeguide.co/#css</span>$scheme    = hexo-config(<span class="hljs-string">'scheme'</span>) ? hexo-config(<span class="hljs-string">'scheme'</span>) : <span class="hljs-string">'Muse'</span>;$variables = base $scheme;<span class="hljs-comment">// Variables Layer</span><span class="hljs-comment">// --------------------------------------------------</span><span class="hljs-keyword">for</span> $variable <span class="hljs-built_in">in</span> $variables  @<span class="hljs-keyword">import</span> <span class="hljs-string">"_variables/"</span> + $variable;<span class="hljs-keyword">for</span> $inject_variable <span class="hljs-built_in">in</span> hexo-config(<span class="hljs-string">'injects.variable'</span>)  @<span class="hljs-keyword">import</span> $inject_variable;<span class="hljs-comment">// Mixins Layer</span><span class="hljs-comment">// --------------------------------------------------</span>@<span class="hljs-keyword">import</span> <span class="hljs-string">"_mixins.styl"</span>;<span class="hljs-keyword">for</span> $inject_mixin <span class="hljs-built_in">in</span> hexo-config(<span class="hljs-string">'injects.mixin'</span>)  @<span class="hljs-keyword">import</span> $inject_mixin;<span class="hljs-comment">// Dark mode colors</span><span class="hljs-comment">// --------------------------------------------------</span>@<span class="hljs-keyword">import</span> <span class="hljs-string">"_colors.styl"</span>;<span class="hljs-comment">// Common Layer</span><span class="hljs-comment">// --------------------------------------------------</span><span class="hljs-comment">// Scaffolding</span>@<span class="hljs-keyword">import</span> <span class="hljs-string">"_common/scaffolding"</span>;<span class="hljs-comment">// Layout</span>@<span class="hljs-keyword">import</span> <span class="hljs-string">"_common/outline"</span>;<span class="hljs-comment">// Components</span>@<span class="hljs-keyword">import</span> <span class="hljs-string">"_common/components"</span>;<span class="hljs-comment">// Schemes Layer</span><span class="hljs-comment">// --------------------------------------------------</span>@<span class="hljs-keyword">import</span> <span class="hljs-string">"_schemes/"</span> + $scheme;<span class="hljs-comment">// Custom Layer</span><span class="hljs-comment">// --------------------------------------------------</span><span class="hljs-keyword">for</span> $inject_style <span class="hljs-built_in">in</span> hexo-config(<span class="hljs-string">'injects.style'</span>)  @<span class="hljs-keyword">import</span> $inject_style;<span class="hljs-comment">//背景图片</span>body&#123;           <span class="hljs-built_in">background</span>:url(https:<span class="hljs-comment">//i.loli.net/2020/08/28/GzMoWTZ4kFKUN6i.png);</span>        <span class="hljs-built_in">background</span>-size:cover;        <span class="hljs-built_in">background</span>-repeat:no-repeat;        <span class="hljs-built_in">background</span>-attachment:fixed;        <span class="hljs-built_in">background</span>-position:center;&#125;</code></pre><p>至此，博客的背景图修改完成！</p></li></ul></li></ul><h3 id="关于背景图的URL链接"><a href="#关于背景图的URL链接" class="headerlink" title="关于背景图的URL链接"></a>关于背景图的URL链接</h3><h5 id="什么是URL链接"><a href="#什么是URL链接" class="headerlink" title="什么是URL链接"></a>什么是URL链接</h5><p>  ​        统一资源定位系统（uniform resource locator;URL）是因特网的万维网服务程序上用于指定信息位置的表示方法。URL是统一资源定位符，对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它，包括我们常见的网址也同样属于URL地址。</p><h5 id="如何得到图片的URL地址"><a href="#如何得到图片的URL地址" class="headerlink" title="如何得到图片的URL地址"></a>如何得到图片的URL地址</h5><p>  ​        要想我们的博客在网络访问后图片能够正常的显示，我们就必须保证这张图片已经成为了互联网上的资源，这样我们就能通过URL定位该图片，否则计算机本地的图片可不能被普通人未经授权地通过互联网看到哦！</p><p>  ​        因此，我们就需要了解一种能将本地图片上床并得到URL地址的工具——图床。</p><p>  ​        官方对于图床的解释：图床一般是指储存图片的服务器，有国内和国外之分。国外的图床由于有空间距离等因素决定访问速度很慢影响图片显示速度。国内也分为单线空间、多线空间和CDN加速三种。</p><p>  ​        我所使用的是评价还不错的<a href="https://sm.ms/" target="_blank" rel="noopener">SM.MS</a>, 国外一家免费且免注册的图床。</p><p>  大功告成！！</p><p>  溜了</p><p>  白白！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo中的常见命令</title>
    <link href="/2020/08/28/H%E2%80%9CHexo%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/08/28/H%E2%80%9CHexo%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>​    初步使用Hexo我们常用的命令</p><a id="more"></a><pre><code class="hljs routeros">hexo new <span class="hljs-string">"postName"</span># 新建文章hexo new<span class="hljs-built_in"> page </span><span class="hljs-string">"pageName"</span># 新建页面hexo generate # 生成静态页面至public目录hexo<span class="hljs-built_in"> server</span># 本地预览页面默认端口4000，可以通过‘ctrl+c’关闭serverhexo deploy # 将文章部署到Githubhexo version# 查看Hexo的版本</code></pre><ul><li>常用的缩写命令：</li></ul><pre><code class="hljs routeros">hexo n == hexo new hexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy</code></pre><ul><li>常用的组合命令：</li></ul><pre><code class="hljs nginx"><span class="hljs-attribute">hexo</span> s -g<span class="hljs-comment"># 生成并本地预览</span>hexo d -g<span class="hljs-comment"># 生成并上传</span></code></pre><ul><li>写文章时需要执行的命令：</li></ul><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">'文章名称'</span></code></pre><p>​    此时，Hexo会自动帮助我们在_posts文件下生成相关的md文件，使用Typora打开该文件即可开始编辑，使用该命令的好处是能够在文件夹中自动帮助我们生成文章的创建时间。当然，也可以选择把事先写好的md文件复制到_posts文件夹中。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>疫情期间的一点感想</title>
    <link href="/2020/06/21/%E7%96%AB%E6%83%85%E6%9C%9F%E9%97%B4%E7%9A%84%E4%B8%80%E7%82%B9%E6%84%9F%E6%83%B3/"/>
    <url>/2020/06/21/%E7%96%AB%E6%83%85%E6%9C%9F%E9%97%B4%E7%9A%84%E4%B8%80%E7%82%B9%E6%84%9F%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><p>​    目前呆在家里的这种状态让我感到很不安，疫情一下打乱了原本正常的生活，我也一直处于有些焦虑的感觉。总之就是很不安，一想到这半年本该是在好好适应大学生活，彻底完成从一个高中生转变成一个大学生的过程，需要找到自己合适的节奏来选择自己应该努力的方向。但是如今回到家里，似乎又重新回到了2019年刚刚高考完的那个暑假，家里轻松的氛围让我很难像在学校那样集中精神，从一开始的干劲满满到现在提前进入假期生活。我不知道同龄人、同学们的状态是不是和我一样，还是他们会比我做的好，排除这些干扰，在家依然收获满满。每次想到这里，我总是会从内心麻醉自己，有选择地去相信前者。但每天我都会懊恼于这种选择，我又希望自己不要虚度光阴，又难以坚持自己想要成为的那副摸样。于是，日子一天一天的就这样流了过去，如今总结，收获甚微。我一直希望自己不要活成自己讨厌的摸样，曾经的我应该觉得好吃懒做是讨厌的、混吃等死是讨厌的，可现在，我应该觉得“思想勤奋、身体懒惰”是同样讨厌的、用还没实现的未来许诺麻痹自己的是同样讨厌的、值得认真付出的事不能坚持到底是同样讨厌的。而这些讨厌就是现在的我，我总是在想是什么原因不能让我做那个我想要的成为的人，最近跟别人聊起我总是说，“在家根本没法学”，这是一个连自己都无法说服的借口，所以今天也想从头到尾总结一下真正地原因究竟是什么，而这些因素又能不能得到解决。为什么坚持不下去？我觉得是动机不够强烈，目前我想要坚持做的事无非就是两类：一类是面向考试检测、一类就是自己想做的。面对考试的复习工作，始终觉得还有充足的时间，可以晚点再开始，简单说就是不见棺材不落泪。而对于自己想做的事，就是明明知道做了就是正确的，但似乎总是觉得可做可不做，而最终都是选择了不做。我现在来看，想要解决必须要把动机变得更加明确，单单只是知道结果的优劣其实很难让我坚持，很多百利而无一害的事情都被我搁浅。所以这里就出现了第一个需要思考的问题：怎样能将动机变得更加明确？一两个小时的注意力集中不算是一件比较难完成的工作，但是连续多天、每天多次的注意力集中就变得困难起来，这应该就是受到比较严重的外界干扰所造成的。其中最需要解决的就是手机的使用，这是第二个问题。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TED-向死而生</title>
    <link href="/2020/06/10/TED-%E5%90%91%E6%AD%BB%E8%80%8C%E7%94%9F/"/>
    <url>/2020/06/10/TED-%E5%90%91%E6%AD%BB%E8%80%8C%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<p>​        欣然地去面对那些已经降临的不幸吧，从它降临到你身上的那一刻起，他就已经成为了你生活的一部分。抗拒它、抵触它难道不是在抵触自己吗？</p><a id="more"></a><p>​    生死无法治疗，疾病的确会使人走向生命的终点，但是它并不是死亡本身。医院是治疗疾病的地方，而不是面对生死的地方。</p><p>​    用温暖迎接悲痛，而不是厌恶。</p><p>​    人类对食物的需求带来了烹饪，对遮蔽身体的需求促成了时尚，而对时间的服从则促使人们发明了音乐。既然死亡也是生命中必不可少的一部分，我们又能因它而创造出些什么呢？</p><p>​    可以让死亡夺走我们的身体，但不要让它夺走我们的想象力。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>图——最小生成树中的两种算法</title>
    <link href="/2020/05/19/%E5%9B%BE%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%AD%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%AE%97%E6%B3%95/"/>
    <url>/2020/05/19/%E5%9B%BE%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%AD%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="图——最小生成树中的两种算法"><a href="#图——最小生成树中的两种算法" class="headerlink" title="图——最小生成树中的两种算法"></a>图——最小生成树中的两种算法</h1><h2 id="1-最小生成树"><a href="#1-最小生成树" class="headerlink" title="1.最小生成树"></a>1.最小生成树</h2><blockquote><p>什么是最小生成树</p></blockquote><p>​    最小生成树是指以权值和最小的路径连通整个图中的所有顶点。</p><p>​    </p><h2 id="2-Prim算法"><a href="#2-Prim算法" class="headerlink" title="2.Prim算法"></a><em>2.Prim算法</em></h2><h3 id="1-1Prim算法的主要思想"><a href="#1-1Prim算法的主要思想" class="headerlink" title="1.1Prim算法的主要思想"></a>1.1Prim算法的主要思想</h3><p>​    确定一个根，在所有已经连接的顶点之中比较所有权值，选择最小的一边，将另一端的顶点记录，不断延申，直到连接完所有的顶点。</p><h3 id="1-2-Prim算法的代码实现"><a href="#1-2-Prim算法的代码实现" class="headerlink" title="1.2 Prim算法的代码实现"></a>1.2 Prim算法的代码实现</h3><h3 id="1-3-Prim算法的优势"><a href="#1-3-Prim算法的优势" class="headerlink" title="1.3 Prim算法的优势"></a>1.3 Prim算法的优势</h3><p>​    适用于稠密图建立最小生成树</p><h2 id="3-Kruskal-算法"><a href="#3-Kruskal-算法" class="headerlink" title="3.Kruskal 算法"></a><em>3.Kruskal 算法</em></h2><h3 id="2-1-Kruskal算法的主要思想"><a href="#2-1-Kruskal算法的主要思想" class="headerlink" title="2.1 Kruskal算法的主要思想"></a>2.1 Kruskal算法的主要思想</h3><p>​    把整张图看成是没有顶点的非连通图，通过选择最小权值两端，如果两端不在同一个连通分量上，就把他们合并成同一个连通分量；否则，继续选择下一个最小的权值。</p><h3 id="2-2-Kruskal算法的代码实现"><a href="#2-2-Kruskal算法的代码实现" class="headerlink" title="2.2 Kruskal算法的代码实现"></a>2.2 Kruskal算法的代码实现</h3><h3 id="2-3-Kruskal算法的优势"><a href="#2-3-Kruskal算法的优势" class="headerlink" title="2.3 Kruskal算法的优势"></a>2.3 Kruskal算法的优势</h3><p>​    Kruskal算法针对图的边展开，因此更适用于边数较少的稀疏图建立最小生成树。</p><h1 id="图——最短路径"><a href="#图——最短路径" class="headerlink" title="图——最短路径"></a>图——最短路径</h1><pre><code>&gt; 研究某两个固定顶点之间的权值和最小的路径</code></pre><h2 id="1-Dijkstra算法"><a href="#1-Dijkstra算法" class="headerlink" title="1.Dijkstra算法"></a>1.Dijkstra算法</h2><blockquote><p>计算某个源点到其余个点的最短路径问题</p></blockquote><h3 id="1-1Dijkstra算法的主要思路"><a href="#1-1Dijkstra算法的主要思路" class="headerlink" title="1.1Dijkstra算法的主要思路"></a>1.1Dijkstra算法的主要思路</h3><p>​    </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法——线索二叉树</title>
    <link href="/2020/04/28/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/04/28/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>线索二叉树的引入</p></blockquote><p>​        二叉树的结构特点会导致有大量的指针域空间的浪费，并且在二叉树的遍历时，每一次要想知道该结点的前驱和后继都需要进行一次遍历，这样会导致空间和时间上的浪费。因此，我们利用浪费的指针域，引入线索二叉树，同时解决上述两个问题。</p><h2 id="线索二叉树的原理"><a href="#线索二叉树的原理" class="headerlink" title="线索二叉树的原理"></a>线索二叉树的原理</h2><p>​        初步想法是在二叉树中，我们利用没有指向孩子的指针域，使其指向该结点的前驱或后继。并且规定，原本指向左孩子的指针域负责指向前驱结点，原本指向右孩子的指针域负责指向后继结点。</p><p>​        为了方便记忆，我们可以把二叉树按照某种遍历次序想象成一个线性表，从左到右就是从前到后，方便记忆前驱和后继的指针位置。</p><p>​        但是，这样的方式会导致我们无法得知，在指针域中究竟指向的是该结点的孩子结点还是指向前驱或后继。为此，我们需要稍加修改结点的结构，在其中加入两个域，分别为 ltag 和 rtag，用于分辨上述问题。</p><div class="table-container"><table><thead><tr><th>数值</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>rtag</td><td>后继结点</td><td>右孩子结点</td></tr><tr><td>ltag</td><td>前驱结点</td><td>左孩子结点</td></tr></tbody></table></div><blockquote><p> 线索存储结点的结构定义代码如下</p></blockquote><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;Link,Thread&#125; Pointertag;<span class="hljs-comment">//Link==0，表示指向左右孩子的指针；</span><span class="hljs-comment">//Thread==1，表示指向前驱或后继</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiThrnode</span></span><span class="hljs-class">&#123;</span>TElemType data;<span class="hljs-comment">//数据结点</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiThrnode</span> *<span class="hljs-title">rchild</span>, *<span class="hljs-title">lchild</span>;</span><span class="hljs-comment">//左右孩子结点</span><span class="hljs-comment">//左右标签</span>PointerTag LTag;PointerTag RTag;&#125;</code></pre><h2 id="线索二叉树的线索化"><a href="#线索二叉树的线索化" class="headerlink" title="线索二叉树的线索化"></a>线索二叉树的线索化</h2><p>​        线索化就是对二叉树以某种次序的遍历使其变成线索二叉树，其过程就是在遍历的过程中修改空白指针域的值</p><blockquote><p>线索化的递归函数代码实现如下（以中序为例）</p></blockquote><pre><code class="hljs c">BiThrTree pre;<span class="hljs-comment">//全局变量，始终指向刚刚访问过的结点</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InThrreading</span><span class="hljs-params">(BiThrTree p)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(p)&#123;InThrreading(p-&gt;lchild);<span class="hljs-keyword">if</span>(!p-&gt;lchild)<span class="hljs-comment">//如果没有左孩子</span>&#123;p-&gt;LTag = Thread;<span class="hljs-comment">//左标签赋值为1</span>p-&gt;lchild = pre;<span class="hljs-comment">//左指针指向前驱</span>&#125;<span class="hljs-keyword">if</span>(!pre-&gt;rchild)<span class="hljs-comment">//如果前驱没有右孩子</span>        &#123;pre-&gt;Rtag = Thread;<span class="hljs-comment">//右标签赋值为1</span>            pre-&gt;rchild = p;<span class="hljs-comment">//右指针指向后继（当前结点p）</span>&#125;pre = p;<span class="hljs-comment">//保持pre始终指向刚刚访问过的结点</span>InThrreading(p-&gt;rchild);&#125;&#125;</code></pre><p>通过上述代码，我们不难发现，线索化的递归代码，与之前的中序遍历的递归代码结构完全相同，就只是改变了对结点进行的访问操作。</p><h2 id="线索二叉树的遍历"><a href="#线索二叉树的遍历" class="headerlink" title="线索二叉树的遍历"></a>线索二叉树的遍历</h2><p>​        既然提出了线索二叉树是为了解决二叉树的遍历问题，那么我们一起看看实现遍历的代码究竟是怎样的。</p><p>​        对线索二叉树的遍历，其实可以看成是对一个双向链表的遍历，我们使一个头结点指向线索二叉树的根结点。头结点的rchild指向树的根节点，lchild指向</p><blockquote><p>线索二叉树的遍历代码</p></blockquote><pre><code class="hljs c"><span class="hljs-function">Status <span class="hljs-title">InOrderTraverse_Thr</span> <span class="hljs-params">(BiThrTree T)</span><span class="hljs-comment">//T即为二叉树的头结点</span></span><span class="hljs-function"></span>&#123;BiThrTree p;    p = T-&gt;lchild;<span class="hljs-comment">//使p指向T的根节点</span>    <span class="hljs-keyword">while</span>(p != T)<span class="hljs-comment">//p = T时，说明该二叉树是空树或遍历结束</span>    &#123;    <span class="hljs-keyword">while</span>(p-&gt;LTag == Link)   <span class="hljs-comment">//说明结点有左孩子</span>        &#123;            p = p-&gt;lchild;<span class="hljs-comment">//p指向p的左孩子</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,p-&gt;data);        &#125;        <span class="hljs-keyword">while</span>(p-&gt;RTag == Thread &amp;&amp; p-&gt;rchild != T)<span class="hljs-comment">//结点没有右孩子，</span>            <span class="hljs-comment">//并且不是中序遍历最后一个结点</span>      &#123;            p = p-&gt;rchild;<span class="hljs-comment">//p指向p的后继结点</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>, p-&gt;data);        &#125;        p = p-&gt;rchild;    &#125;    <span class="hljs-keyword">return</span> OK;&#125;</code></pre><p>这段代码的就是进行了一个链表的扫描，所以它的时间复杂度是0（n）。</p><h2 id="线索二叉树的应用"><a href="#线索二叉树的应用" class="headerlink" title="线索二叉树的应用"></a>线索二叉树的应用</h2><p>​        当一个二叉树需要进行遍历或是查找结点在某种次序遍历中的前驱或后继，那么就可以使用线索二叉树的存储结构。</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的遍历</title>
    <link href="/2020/04/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <url>/2020/04/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><a id="more"></a><h4 id="推导遍历结果的方法总结"><a href="#推导遍历结果的方法总结" class="headerlink" title="推导遍历结果的方法总结"></a>推导遍历结果的方法总结</h4><ul><li><p>能够推到遍历结果的条件：</p><pre><code>    - 已知中序遍历序列        - 已知&lt;u&gt;前序遍历&lt;/u&gt; 或 &lt;u&gt;后序遍历&lt;/u&gt; 其中的任意一个</code></pre></li></ul><ul><li><p>方法总结：</p><pre><code> 1.由前序序列的首位或后序序列的末尾得到二叉树的根结点 2.由中序序列得到根结点的左右两边分别是左子树和右子树 3.再根据前序序列或后序序列分别得到根结点的孩子结点 4.再回到中序序列确定左右孩子 5.最后重复3，4步骤直到确定完整棵二叉树的所有结点。</code></pre></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法——串</title>
    <link href="/2020/04/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%9D%97%E9%93%BE%E4%B8%B2/"/>
    <url>/2020/04/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%9D%97%E9%93%BE%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构与算法——串"><a href="#数据结构与算法——串" class="headerlink" title="数据结构与算法——串"></a>数据结构与算法——串</h1><h2 id="块链串"><a href="#块链串" class="headerlink" title="块链串"></a><em>块链串</em></h2><a id="more"></a><blockquote><p>前言</p></blockquote><p>​    在学习串的存储结构时我们知道，顺序存储的方式往往会导致越界的问题出现，然而当我们采用链式存储结构动态分配内存时，如果仅仅是每一个结点只对应一个字符，就会导致很大的一部分空间被浪费。因此，我们使用块链串的概念来完善串的链式存储结构。</p><blockquote><p>什么是块链串</p></blockquote><p>​    简单来说，块链串就是将链表中的结点定义成一个数组，实现一个结点可以存储多个字符。而具体存储多少个字符，则要依据实际的情况做出选择。</p><blockquote><p>块链串的结构定义</p></blockquote><pre><code class="hljs c"> <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">clock</span></span><span class="hljs-class">&#123;</span>  <span class="hljs-keyword">char</span> ch[BLOCK_SIZE];<span class="hljs-comment">//用于存放字符串的数组  </span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">block</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//用于链接的指针</span>&#125; Block;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>  Block *head;<span class="hljs-comment">//指向块链串的头结点</span>  Block *tail;<span class="hljs-comment">//始终指向块链串的尾结点</span>  <span class="hljs-keyword">int</span> len;<span class="hljs-comment">//记录块链串的总长度</span>&#125;BLString;</code></pre><blockquote><p>块链串的初始化</p></blockquote><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">blstr_init</span><span class="hljs-params">(BLString *T)</span></span><span class="hljs-function"></span>&#123;    T -&gt;len = <span class="hljs-number">0</span>;    T -&gt;head = <span class="hljs-literal">NULL</span>;    T -&gt;tail = <span class="hljs-literal">NULL</span>;&#125;</code></pre><blockquote><p>块链串的SubString(BLString src, int pos, int len， BLString *sub,)函数</p></blockquote><p>​    该函数的作用是，用Sub返回串S中第pos个字符起长度为len的子串。</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">blstr_substr</span><span class="hljs-params">(BLString src, <span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">int</span> len, BLString *sub)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i, j, k, count;    Block *p, *r;        <span class="hljs-comment">//是否满足题目条件的判断</span>    <span class="hljs-comment">//原串是否为空</span>    <span class="hljs-keyword">if</span>(src.head == <span class="hljs-literal">NULL</span> &amp;&amp; src.tail == <span class="hljs-literal">NULL</span> &amp;&amp; src.len == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">//pos的位置是否正确</span>    <span class="hljs-keyword">if</span>(len &lt;= <span class="hljs-number">0</span> || pos &lt; <span class="hljs-number">0</span> || pos &gt; src.len - <span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">//使指针p移动到pos的位置上</span>    <span class="hljs-keyword">for</span>(count = <span class="hljs-number">1</span>, p = src.head; pos &gt; count*BLOCK_SIZE; p = p-&gt;next, count++);    <span class="hljs-comment">//初始化指针r</span>    r = sub-&gt;head;    <span class="hljs-comment">//i用于控制存入的变量个数</span>    i = <span class="hljs-number">0</span>;    <span class="hljs-comment">//j用于控制r中的数组切换</span>    j = <span class="hljs-number">0</span>;    <span class="hljs-comment">//k用于控制src中的数组的切换</span>    k = (pos % BLOCK_SIZE);          <span class="hljs-comment">//如果pos之后的字符串不足len个，则返回src在pos之后的所有字符</span>    <span class="hljs-keyword">if</span>(pos + len &gt; src.len)        len = src.len -pos;    <span class="hljs-keyword">while</span>(i &lt; len)    &#123;        <span class="hljs-keyword">if</span>(!r)        &#123;            r = (Block*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Block));            <span class="hljs-keyword">if</span>(!r)                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            r-&gt;next = <span class="hljs-literal">NULL</span>;            <span class="hljs-comment">//解决第一次(*sub).head的初始化，使他指向r的以一个块</span>            <span class="hljs-keyword">if</span>(!sub-&gt;head)                sub-&gt;head = sub-&gt;tail = r;            <span class="hljs-comment">//保证(*sub).tail始终指向r的末尾块</span>            <span class="hljs-keyword">else</span>            &#123;                sub-&gt; tail -&gt; next = r;            &#125;        &#125;        <span class="hljs-comment">//开始将pos之后len长度的字符串输入到r中</span>        <span class="hljs-keyword">while</span>(i &lt; len)        &#123;            r-&gt;ch[j] = p-&gt;ch[k];            j = (<span class="hljs-number">1</span> + j) % BLOCK_SIZE;            k = (<span class="hljs-number">1</span> + k) % BLOCK_SIZE;            i++;            <span class="hljs-comment">//控制p中的数组切换</span>            <span class="hljs-keyword">if</span>(!k)                p = p-&gt;next;            <span class="hljs-comment">//控制r中的数组切换</span>            <span class="hljs-keyword">if</span>(!j)            &#123;                r = r-&gt;next;                <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//返回到上一级循环，给r重新分配一个BLOCK，并且调整tail指针的位置</span>            &#125;        &#125;    &#125;    sub-&gt;len = len;    <span class="hljs-comment">//将r中最后一个BLOCK中没有字符的部分用 '#'补齐</span>    count = (len - <span class="hljs-number">1</span>) % BLOCK_SIZE + <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(count &lt; BLOCK_SIZE)    &#123;        sub-&gt;tail-&gt;ch[count] = <span class="hljs-string">'#'</span>;        count ++;    &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre><p>​    </p><ul><li>由上述代码，总体的结构是一个大的循环，循环的作用是给sub创建一个新的结点。循环结构的特别之处在于加入条件区别了sub的初始化和之后的链接。</li><li>块链串的其他操作函数，之后遇到时在具体介绍吧！</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法-树与二叉树</title>
    <link href="/2020/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a><strong>数据结构与算法</strong></h1><a id="more"></a><h2 id="树的表示方法"><a href="#树的表示方法" class="headerlink" title="树的表示方法"></a><u>树的表示方法</u></h2><h4 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a><em>孩子表示法</em></h4><p>每个结点设置多个指针域，指针指向子树的根结点。即多重链表表示法<br>由于每个结点的度不相同，指针域的个数难以统一，通过两种方案解决</p><ul><li><p>方案一</p><p>以树的度作为指针域的个数 ——在各个结点的度相差很大时会导致空间的浪费</p><p>适用于结点的度相差不大的情况</p></li><li><p>方案二</p><p>再取一个位置用来保存统计出的结点指针域的个数，提高了空间利用效率，但是却浪费了时间。</p></li><li><p>综上所述</p><p>采取数组和单链表综合的方法，把树中的结点采用线性存储结构连成一个数组，并将其作为头指针连接一个由孩子结点构成的链表。</p><blockquote><p>结构定义代码如下</p></blockquote></li></ul><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_TREE_SIZE 100</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CTNode</span>   //孩子结点 -&gt; 孩子链表 </span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> child;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CTNode</span> *<span class="hljs-title">next</span>;</span>&#125; *ChildPtr;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>  //表头结构 -&gt; 表头数组</span><span class="hljs-class">&#123;</span>    TElemType data;    ChildPtr firstchild;&#125; CTBox;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>  //树结构</span><span class="hljs-class">&#123;</span>    CTBox nodes [MAX_TREE_SIZE];    <span class="hljs-keyword">int</span> r, n;   <span class="hljs-comment">//根的位置和结点数</span>&#125;CTree;</code></pre><h4 id="双亲孩子表示法"><a href="#双亲孩子表示法" class="headerlink" title="双亲孩子表示法"></a><em>双亲孩子表示法</em></h4><ul><li><p>由于查找某个结点的双亲需要遍历整个树，复杂度高, 升级为双亲孩子表示法</p><p>简单修改：在头指针中加入一个域用于存储该节点双亲的位置，双亲不存在值为-1。</p></li></ul><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_TREE_SIZE 100</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CTNode</span>  //*孩子结点 -&gt; 孩子链表* </span><span class="hljs-class"></span><span class="hljs-class">&#123;</span>  <span class="hljs-keyword">int</span> child;  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CTNode</span> *<span class="hljs-title">next</span>;</span>&#125; *ChildPtr;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> //*表头结构 -&gt; 表头数组*</span><span class="hljs-class"></span><span class="hljs-class">&#123;</span>  TElemType data;  ChildPtr parent, firstchild;  <span class="hljs-comment">//*增加一个位置存储双亲的位置*</span>&#125; CTBox;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> //*树结构*</span><span class="hljs-class"></span><span class="hljs-class">&#123;</span>  CTBox nodes [MAX_TREE_SIZE];  <span class="hljs-keyword">int</span> r, n;  <span class="hljs-comment">//*根的位置和结点数*</span>&#125;CTree;</code></pre><h4 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a><em>孩子兄弟表示法</em></h4><ul><li><p>优点： 把复杂的树转化成为一颗二叉树</p><blockquote><p>结构定义</p></blockquote><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CSNode</span></span><span class="hljs-class"></span><span class="hljs-class">&#123;</span>  TElemtype data;  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CSNode</span> *<span class="hljs-title">firstchild</span>, *<span class="hljs-title">rightsib</span>;</span> <span class="hljs-comment">//每一个结点包含三个部分，数据域、长子指针、右兄弟指针</span>&#125;CSNode, *CSTree;</code></pre></li></ul><h2 id="二叉树的性质总结"><a href="#二叉树的性质总结" class="headerlink" title="二叉树的性质总结"></a><u>二叉树的性质总结</u></h2><blockquote><p>性质一</p></blockquote><script type="math/tex; mode=display">二叉树的第i层上最多有2^{k-1}个结点</script><blockquote><p>性质二</p></blockquote><script type="math/tex; mode=display">深度为k的二叉树最多有2^{k}-1个结点。(k\ge1)</script><blockquote><p>性质三</p></blockquote><script type="math/tex; mode=display">对任何一个二叉树，若度为2的结点个数是n_2,那么终端结点的个数是(n_2+1)</script><blockquote><p>性质四</p></blockquote><script type="math/tex; mode=display">具有n个结点的完全二叉树的深度是[log_2n]+1\\其[x]表示不大于x的最大整数</script><blockquote><p>性质五</p></blockquote><script type="math/tex; mode=display">如果一个完全二叉树有n个结点，深度为[log_2n]+1，i是结点的编号(每层从左到右)，那么</script><script type="math/tex; mode=display">1.如果i=1，那么i是根节点，没有双亲；如果i>1,那么其双亲是[\frac{i}{2}]</script><script type="math/tex; mode=display">2.如果2i>n,那么结点i没有左孩子；否则其左孩子是结点2i</script><script type="math/tex; mode=display">3.如果2i+1>n,那么结点没有右孩子，否则其右孩子是结点(2i+1)</script><h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a><u>二叉树的存储结构</u></h2><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a><em>顺序存储结构</em></h4><p>​        使用数组，按照二叉树的编号储存二叉树的结点</p><pre><code>- 对于完全二叉树，由于编号的严格性，完全二叉树能够体现结点之间逻辑关系- 对于普通二叉树，不存在的结点设置成 ^ ,但是会导致存储空间的浪费</code></pre><h4 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a><em>二叉链表</em></h4><blockquote><p> 二叉树的二叉链表的结点结构定义</p></blockquote><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> </span><span class="hljs-class">&#123;</span>    TElemType data;<span class="hljs-comment">//结点数据</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>, *<span class="hljs-title">rchild</span>;</span><span class="hljs-comment">//左右孩子指针</span>&#125; BiTnode, *BiTree</code></pre><h2 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a><u>二叉树的建立</u></h2><h4 id="按照前序序列建立二叉树"><a href="#按照前序序列建立二叉树" class="headerlink" title="按照前序序列建立二叉树"></a><em>按照前序序列建立二叉树</em></h4><blockquote><p>函数void CreateBitree（ BiTree *T )的描述</p></blockquote><p>​        将一般二叉树处理成扩展二叉树，并将结点的数据按照前序序列的顺序输入，若数据域为空，那么数据域中输入”#”</p><blockquote><p>代码实现</p></blockquote><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateBiTree</span> <span class="hljs-params">(Bitree *T)</span></span><span class="hljs-function"></span>&#123;    ElemType ch;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%c"</span>, &amp;ch);    <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">'#'</span>)        *T = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">else</span>     &#123;*T = (BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BiTree));        <span class="hljs-keyword">if</span>(!*T)        <span class="hljs-built_in">exit</span>(OVERFLOW);        (*T)-&gt;data = ch;        <span class="hljs-comment">//需要依据前序序列的录入顺序</span>        <span class="hljs-comment">//使用了递归的调用</span>        CreateBiTree(&amp;(*T)-&gt;lchlid);<span class="hljs-comment">//构造左子树</span>        CreatebiTree(&amp;(*T)-&gt;rchild);<span class="hljs-comment">//构造右子树</span>    &#125;&#125;</code></pre><h4 id="按照中序或后续序列建立二叉树"><a href="#按照中序或后续序列建立二叉树" class="headerlink" title="按照中序或后续序列建立二叉树"></a><em>按照中序或后续序列建立二叉树</em></h4><p>​        <u>代码的内容一致，需要改变的地方有两处：</u>    </p><ol><li>输入结点数据的顺序要依照中序或后序序列的顺序</li><li>代码中的递归部分和构造左右子树部分的代码的相对位置适当调整</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
